### 20分

dfs暴力枚举插入情况，插入次数至多为5，所以迭代深度至多为5。

### 60分

不难发现只需要找到  $ S_i $  对应的  $ T_j $  位置，接下来就可以将  $ T $  划分成若干段 `AB` 序列，拼接 `AB` 序列即可。

考虑区间  $ [l,r] $  ，判断能否从无拼出。

* 显然需要满足 `A` 的数量和 `B` 的数量相同。

* 若成本最少，不妨假设  $ x<y $  ，需要尽量用 `AB` 。

  类似括号序列。令  $ s_i $  表示  $ T $  中前  $ i $  个字符中 `A` 的个数减去 `B` 的个数。

  则 `BA`  至少需要使用  $ s_r-min_{i=l-1}^{r}s_i $   ，`AB` 个数也不难计算。

所以用  $ cost(l,r) $  表示区间  $ [l,r] $  的最少花费

那么就是一个线性DP

令  $ f(i,j) $  表示  $ S_i $  对应位置为  $ T_j $  的最小成本，则  $ f(i,l-1)+cost(l,r)\rightarrow f(i+1,r+1),s_{l-1}=s_r $ 

时间复杂度为  $ O(|S||T|^2) $ 

### 100分

优化每一轮的转移。

首先把  $ s_i $  相同的放在一起处理。

注意到代价需要维护  $ min_{i=l-1}^{r}s_i $  ，可以用单调栈/笛卡尔树（建立笛卡尔树后在笛卡尔树上 DFS 转移）优化。

时间复杂度为  $ O(|S||T |)  $ 
